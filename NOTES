NOTES -- this is an informal/temporary TODO file
- all library code is in lib/
  * ideally there will be few/no cpp files, so using the library just amounts to adding the lib/ directory to your include path
- all test code is in test/ -- these are just informal ad-hoc tests and prototype code, nothing that will be kept around
- the "actual" tensor lib prototype code is in test/contraction_prototype.cpp
- some prototype code for strongly-typed vectors (which distinguish prime/dual spaces and "named" spaces)
  is in test/strongly_typed_vector_prototype.cpp

current goals:
- interop with some basic Eigen stuff (calling SVD, etc on 2-tensors)
  * API for calling external methods on the arrays stored by vectors and 2-tensors (use eigen's "Map" class/function)
  * have a set of wrapper functions for common Eigen operations (e.g. SVD, LDLT, etc) which hide Eigen
    within the strongly typed formalism.
  * some sort of abstraction layer for using Eigen methods on our tensor classes.  self-contained and NOT intertwined in the tensor lib
  * could use templatized conversion method which converts to generic type
x operator overloads for expression templates
- scalar multiplication/division in expression templates
- symmetric and antisymmetric 2 tensors (full contraction here requires a custom natural pairing -- make this a
  parameter of the multiplication expression template --
  * NOTE: it should also depend on the basis, and in the situation where the natural pairing is "perfect", it will be the
    "standard inner product" on the components)
  * NOTE: that there is a mutually exclusive choice between having a perfect natural pairing (no extra scalar multiples of components
    necessary when contracting) and an isometric vector representation (so that the norm of the vector is the norm of the tensor).
- down-casting (to more-specific types) (up-casting (to less-specific types) already happens through expression templates)
  * something like
      (a(i,j)*m(j,k)*a(k,l)).the_human_guarantees_that_this_is_a_Tensor2Symmetric<i,j>(I)
    which would produce an expression template -- the indices (i,j) would be "bundled" into the index I,
    which is of type Tensor2Symmetric_t<...>::Index_t<...>
- strong typing for vectors -- named vector spaces (including "Generic") and prime/dual distinction (including self-dual)
  * default values should be "Generic" vector space ID and self-dual
  * canonical isomorphism for tensor2 -> vector will need to take into account basis
x trace-type expression templates (where a tensor is contracted with itself, a case which is distinct from * style expression templates)
x prohibiting 3+ summed index expressions
x assignment expression templates
x check assignment for aliasing
- column/row/block extraction/addressing
- "eval" method on expression templates (which take a list of free indices) which produce an intermediate value


future goals:
- standard in-line linear algebra notation
  * for example, if A is a matrix and v is a vector, "A*v" should be equivalent to "A(i,j)*v(j)", but obviously
    without the need to used an indexed expression.
- optimize evaluation algorithm (ordering operations to do the minimal amount of computation)
- vectorizing as many operations as possible
- template specializations for particular tensor contractions for speed (using mathematical special cases)
  * for example, an antisymmetric 3x3 2-tensor contracted with a 3-vector is just a cross product
  * a diagonal 2-tensor contracted with a vector is just component-wise scaling
- in strongly typed vector template identifier types, require certain tags (e.g. static member constants)
  in the template parameters -- vector space identifier, vector space basis, etc.
- certain linear algebraic expressions simplify greatly when expressed in a particular basis,
  so having a formal mechanism to work with explicit bases may clarify and simplify some calculations

features:
- vectors and non-symmetric 2-tensors
- indexed tensor expressions, such as "A(i,j)*u(j) + v(i)"
- for 1-dimensional vectors, type coersion to/from the scalar type via canonical
  isomorphism (a 1-dimensional real vector space is canonically isomorphic to R)
- for 2-tensors of the form Nx1 or 1xN (referring to the dimension of the factors), type coersion
  to/from the factor types via canonical isomorphisms (R \otimes V = V  and  V \otimes R = V)
