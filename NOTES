NOTES -- this is an informal/temporary TODO file
- all library code is in lib/
  * ideally there will be few/no cpp files, so using the library just amounts to adding the lib/ directory to your include path
- all test code is in test/ -- these are just informal ad-hoc tests and prototype code, nothing that will be kept around
- the "actual" tensor lib prototype code is in test/contraction_prototype.cpp
- some prototype code for strongly-typed vectors (which distinguish prime/dual spaces and "named" spaces)
  is in test/strongly_typed_vector_prototype.cpp

current goals:
- interop with some basic Eigen stuff (calling SVD, etc on 2-tensors)
  * API for calling external methods on the arrays stored by vectors and 2-tensors (use eigen's "Map" class/function)
  * have a set of wrapper functions for common Eigen operations (e.g. SVD, LDLT, etc) which hide Eigen
    within the strongly typed formalism.
  * some sort of abstraction layer for using Eigen methods on our tensor classes.  self-contained and NOT intertwined in the tensor lib
  * could use templatized conversion method which converts to generic type
- strong typing for vectors -- named vector spaces (including "Generic") and prime/dual distinction (including self-dual)
  * default values should be "Generic" vector space ID and self-dual
  * canonical isomorphism for tensor2 -> vector will need to take into account basis
  * canonical isomorphism for vector -> scalar will need to take into account basis (a 1-dimensional vector space always has a
    canonical "unit" basis element which is the real number 1)
- column/row/block extraction/addressing
- "eval" method on expression templates (which take a list of free indices) which produce an intermediate value
  * something like  (a(i,j)*m(j,k)*a(k,l)).eval(l,i)  (this one makes l the first index, and i the second).
- single-vector indexing of built-up tensors of type e.g. Tensor2_t<Tensor2Symmetric,Tensor2Symmetric>
  e.g. in the expression t(i,j,k,l), where t is of type Tensor2_t<Tensor2Symmetric,Tensor2Symmetric>

future goals:
- a rigorous test suite, using Lvd test code -- it can handle everything up through seg faults -- and negative compile
  tests implemented at the build level, so that particular intentional compile errors can be verified to work.
- standard in-line linear algebra notation
  * for example, if A is a matrix and v is a vector, "A*v" should be equivalent to "A(i,j)*v(j)", but obviously
    without the need to use an indexed expression.
- optimize evaluation algorithm (ordering operations to do the minimal amount of computation)
- vectorizing as many operations as possible (in cooperation with loop-unrolling?)
- template specializations for particular tensor contractions for speed (using mathematical special cases)
  * for example, an antisymmetric 3x3 2-tensor contracted with a 3-vector is just a cross product
  * a diagonal 2-tensor contracted with a vector is just component-wise scaling
- in strongly typed vector template identifier types, require certain tags (e.g. static member constants)
  in the template parameters -- vector space identifier, vector space basis, etc.
- certain linear algebraic expressions simplify greatly when expressed in a particular basis,
  so having a formal mechanism to work with explicit bases may clarify and simplify some calculations

random TODOs:
- simplify usage of indices.  Use "Index_t<'i'> i", just to carry the letter, then have that create the stronger type
  NamedIndex_t<Derived,'i'> in the expression template when you call operator() with the index.  maybe use TypedIndex_t
  instead of NamedIndex_t.
- implement [anti]symmetric contiguous_index_to_rowcol_index as a lookup table for speed.
- create Tensor2_i compile-time interface that handles 2-index indexing, printing and so forth

implemented features/items:
x operator overloads for expression templates
x trace-type expression templates (where a tensor is contracted with itself, a case which is distinct from * style expression templates)
x prohibiting 3+ summed index expressions
x assignment expression templates
x check assignment for aliasing
x symmetric 2-tensors
x antisymmetric 2-tensors
x custom natural pairing (for non-isometric parameterizations)
x scalar multiplication/division in expression templates
x unary negation in expression templates
x printing expression templates
x down-casting tensors (extracting symmetries out of "broken apart" indexed tensor expressions);
  "bundling" indices into symmetric and antisymmetric "total" indices
x diagonal 2-tensors
x SVD on 2-tensors, using Eigen
x eigen-decomposition of symmetric 2-tensors, using Eigen


